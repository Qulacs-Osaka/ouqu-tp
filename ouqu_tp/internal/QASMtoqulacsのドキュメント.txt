必要ライブラリ : https://github.com/r1chardj0n3s/parse


今からやること: u,u1,u2,u3,u0ゲート対応
重要注意事項

非対応のゲートも、ゲート行列が取得できれば、DenseMatrixに変換されます。
逆に、ゲート行列が取得不可能なゲートを含む回路は対応していません。
DenseMatrixのcontrol_valueはすべて1にしてください。これは、qulacs 0.3.0にcontrol_valueを取得する関数がないのが原因です。

QASMのゲート名は、qelib1.incで言うと、czまで対応しています。
それ以上やりたいなら、staqを使うといいです。


qulacs_to_QASM(cir: QuantumCircuit) -> typing.List[str]:
量子回路を、QASM風にします。

バージョンは、OpenQASM 2.0ではなく、QulacsQASM Q.9です。
対応するゲートは、CNOT,CZ,SWAP,I,X,Y,Z,H,S,Sdag,T,Tdag,sqrtX,sqrtXdag,RX,RY,RZ,DenseMatrixです。

非対応のゲートも、ゲート行列が取得できれば、DenseMatrixに変換されます。
DenseMatrixのcontrol_valueはすべて1にしてください。これは、qulacs 0.3.0にcontrol_valueを取得する関数がないのが原因です。



QASM_to_qulacs(input_strs: typing.List[str]) -> QuantumCircuit:
QASMファイルを改行ごとに区切ってたList[str]を、回路に戻します。

qubit名はq　の配列で統一してください。
対応するゲートは上と同じです。



DenseMatrixのQualcsQASM形式について

nビットの場合、
DenseMatrix(ターゲットビット数、コントロールビット数,　行列の内容 ,コントロールバリュー) ターゲット、コントロール; という風に書く。
例：
DenseMatrix(2,1,0.707107,0,0,0,-0,-0.707107,0,0,0,0,0.707107,0,0,0,0,0.707107,-0,-0.707107,0,0,0.707107,0,0,0,0,0,0,0.707107,0,0,0.707107,0,1)　q[0],q[1],q[2];
この場合、ターゲット2bitで、コントロール1bit。
そのあとはmat[0][0]の実数、虚数,mat[0][1]… のように続く32個の数が行列を表し、 そのあとはコントロールバリューを表す。
ターゲットビットはq[0]とq[1]
コントロールビットはq[2]バリューは1 
である。


stateのstr形式について

state_to_strs
to_stringして改行ごとに区切る

strs_to_state
それを読み込む